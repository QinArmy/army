package io.army.criteria;

import io.army.lang.Nullable;
import io.army.meta.FieldMeta;

import java.util.List;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;

/**
 * <p>
 * This interface representing primary INSERT statement.This interface is base interface of below:
 *     <ul>
 *         <li>{@link Insert}</li>
 *         <li>{@link io.army.criteria.dialect.ReturningInsert}</li>
 *     </ul>
 * </p>
 *
 * @since 1.0
 */
public interface InsertStatement extends DmlStatement {


    /**
     * <p>
     * This interface representing the capacity ending INSERT statement.
     * </p>
     * <p>
     * <strong>Note:</strong><br/>
     * Application developer isn't allowed to directly use this interface,so you couldn't declare this interface type variable
     * ,because army don't guarantee compatibility to future distribution.
     * </p>
     *
     * @since 1.0
     */
    @Deprecated
    interface _InsertSpec extends _DmlInsertClause<InsertStatement> {

    }

    interface _MigrationOptionClause<R> {

        R migration();
    }

    /**
     * <p>
     * This interface representing the option prefer output literal when output domain column,but not contain
     * comment expression
     * </p>
     * <p>
     * <strong>Note:</strong><br/>
     * Application developer isn't allowed to directly use this interface,so you couldn't declare this interface type variable
     * ,because army don't guarantee compatibility to future distribution.
     * </p>
     *
     * @since 1.0
     */
    interface _PreferLiteralClause<R> {
        R literalMode(LiteralMode mode);
    }


    /**
     * @since 1.0
     */
    interface _NullOptionClause<R> {

        R nullMode(NullMode mode);
    }


    interface _IgnoreReturnIdsOptionClause<R> {

        /**
         * For domain insert mode ony.
         * <p>
         * The effect is that army don't return id that is generated by database to domain bean,
         * so if you invoke getId() method of domain bean,then always return null.
         * </p>
         * <p>
         * satisfy all below:
         *      <ul>
         *          <li>exists conflict clause,eg:MySQL ON DUPLICATE KEY,PostgreSQL ON CONFLICT</li>
         *          <li>non-migration mode,see {@link _MigrationOptionClause#migration()}</li>
         *          <li>{@link io.army.annotation.GeneratorType} of primary key is {@link io.army.annotation.GeneratorType#POST}</li>
         *          <li>insert table is {@link io.army.meta.SingleTableMeta} type</li>
         *          <li>domain insert mode</li>
         *          <li>insert multi-row</li>
         *          <li>don't support RETURNING clause or conflict clause is ignorable(eg:DO NOTHING,WHERE)</li>
         *      </ul>
         *      you have to specified this insert option or throw {@link CriteriaException}.
         * </p>
         */
        R ignoreReturnIds();

    }


    interface _StaticColumnDualClause<T, IR> extends Statement._RightParenClause<IR> {

        Statement._RightParenClause<IR> comma(FieldMeta<T> field);

        _StaticColumnDualClause<T, IR> comma(FieldMeta<T> field1, FieldMeta<T> field2);

    }


    interface _StaticColumnQuadraClause<T, IR> extends Statement._RightParenClause<IR> {

        Statement._RightParenClause<IR> comma(FieldMeta<T> field);

        Statement._RightParenClause<IR> comma(FieldMeta<T> field1, FieldMeta<T> field2);

        Statement._RightParenClause<IR> comma(FieldMeta<T> field1, FieldMeta<T> field2, FieldMeta<T> field3);

        _StaticColumnQuadraClause<T, IR> comma(FieldMeta<T> field1, FieldMeta<T> field2, FieldMeta<T> field3,
                                               FieldMeta<T> field4);

    }


    interface _QueryInsertSpaceClause<T extends Item, R extends Item> {

        T space();

        R space(Function<T, R> function);

        R space(Supplier<SubQuery> supplier);

    }


    interface _ColumnListClause<T, R> {

        Statement._RightParenClause<R> leftParen(FieldMeta<T> field);

        _StaticColumnDualClause<T, R> leftParen(FieldMeta<T> field1, FieldMeta<T> field2);

        Statement._RightParenClause<R> leftParen(FieldMeta<T> field1, FieldMeta<T> field2, FieldMeta<T> field3);

        _StaticColumnQuadraClause<T, R> leftParen(FieldMeta<T> field1, FieldMeta<T> field2, FieldMeta<T> field3,
                                                  FieldMeta<T> field4);

        R parens(Consumer<Consumer<FieldMeta<T>>> consumer);

    }


    /**
     * @since 1.0
     */
    interface _ColumnDefaultClause<T, CR> {

        CR defaultValue(FieldMeta<T> field, Expression value);

        CR defaultValue(FieldMeta<T> field, Supplier<Expression> supplier);

        CR defaultValue(FieldMeta<T> field, Function<FieldMeta<T>, Expression> function);

        CR defaultValue(FieldMeta<T> field, BiFunction<FieldMeta<T>, Expression, Expression> operator,
                        Expression expression);

        CR defaultValue(FieldMeta<T> field, BiFunction<FieldMeta<T>, Object, Expression> operator,
                        @Nullable Object value);

        <E> CR defaultValue(FieldMeta<T> field, BiFunction<FieldMeta<T>, E, Expression> operator, Supplier<E> supplier);

        CR defaultValue(FieldMeta<T> field, BiFunction<FieldMeta<T>, Object, Expression> operator,
                        Function<String, ?> function, String keyName);

    }


    /**
     * @since 1.0
     */
    interface _DomainValueClause<T, VR> {

        <TS extends T> VR value(TS domain);

        <TS extends T> VR value(Supplier<TS> supplier);

        <TS extends T> VR values(List<TS> domainList);

        <TS extends T> VR values(Supplier<List<TS>> supplier);

    }


    interface _StaticValuesClause<VR> {

        VR values();

    }

    interface _DynamicValuesClause<T, VR> {

        VR values(Consumer<ValuesConstructor<T>> consumer);

    }


    interface _ChildPartClause<CR> {

        CR child();

    }

    interface _ParentInsert<CT extends Item> extends Insert, _ChildPartClause<CT> {

    }


    interface _StaticValueLeftParenClause<T, RR> {

        _StaticColumnValueClause<T, RR> leftParen(FieldMeta<T> field, Expression value);

        _StaticColumnValueClause<T, RR> leftParen(FieldMeta<T> field, Supplier<Expression> supplier);

        _StaticColumnValueClause<T, RR> leftParen(FieldMeta<T> field, Function<FieldMeta<T>, Expression> function);

        _StaticColumnValueClause<T, RR> leftParen(FieldMeta<T> field,
                                                  BiFunction<FieldMeta<T>, Expression, Expression> operator,
                                                  Expression expression);

        _StaticColumnValueClause<T, RR> leftParen(FieldMeta<T> field,
                                                  BiFunction<FieldMeta<T>, Object, Expression> operator,
                                                  @Nullable Object value);


        <E> _StaticColumnValueClause<T, RR> leftParen(FieldMeta<T> field,
                                                      BiFunction<FieldMeta<T>, E, Expression> operator,
                                                      Supplier<E> supplier);

        _StaticColumnValueClause<T, RR> leftParen(FieldMeta<T> field,
                                                  BiFunction<FieldMeta<T>, Object, Expression> operator,
                                                  Function<String, ?> function, String keyName);


    }

    interface _StaticColumnValueClause<T, RR> extends Statement._RightParenClause<RR> {

        _StaticColumnValueClause<T, RR> comma(FieldMeta<T> field, Expression value);

        _StaticColumnValueClause<T, RR> comma(FieldMeta<T> field, Supplier<Expression> supplier);

        _StaticColumnValueClause<T, RR> comma(FieldMeta<T> field, Function<FieldMeta<T>, Expression> function);

        _StaticColumnValueClause<T, RR> comma(FieldMeta<T> field,
                                              BiFunction<FieldMeta<T>, Expression, Expression> operator,
                                              Expression expression);

        _StaticColumnValueClause<T, RR> comma(FieldMeta<T> field,
                                              BiFunction<FieldMeta<T>, Object, Expression> operator,
                                              @Nullable Object value);


        <E> _StaticColumnValueClause<T, RR> comma(FieldMeta<T> field, BiFunction<FieldMeta<T>, E, Expression> operator, Supplier<E> supplier);

        _StaticColumnValueClause<T, RR> comma(FieldMeta<T> field, BiFunction<FieldMeta<T>, Object, Expression> operator, Function<String, ?> function, String keyName);

    }

    /**
     * <p>
     * This interface representing SET assignment_list clause in INSERT statement.
     * </p>
     * <p>
     * <strong>Note:</strong><br/>
     * Application developer isn't allowed to directly use this interface,so you couldn't declare this interface type variable
     * ,because army don't guarantee compatibility to future distribution.
     * </p>
     */
    interface _StaticAssignmentSetClause<T, SR> {

        SR set(FieldMeta<T> field, Expression value);

        SR set(FieldMeta<T> field, Supplier<Expression> supplier);

        SR set(FieldMeta<T> field, Function<FieldMeta<T>, Expression> function);

        <E> SR set(FieldMeta<T> field, BiFunction<FieldMeta<T>, E, Expression> valueOperator, @Nullable E value);

        <E> SR set(FieldMeta<T> field, BiFunction<FieldMeta<T>, E, Expression> valueOperator, Supplier<E> supplier);

        SR set(FieldMeta<T> field, BiFunction<FieldMeta<T>, Object, Expression> valueOperator, Function<String, ?> function, String keyName);


        SR ifSet(FieldMeta<T> field, Supplier<Expression> supplier);

        SR ifSet(FieldMeta<T> field, Function<FieldMeta<T>, Expression> function);

        <E> SR ifSet(FieldMeta<T> field, BiFunction<FieldMeta<T>, E, Expression> valueOperator, @Nullable E value);

        <E> SR ifSet(FieldMeta<T> field, BiFunction<FieldMeta<T>, E, Expression> valueOperator, Supplier<E> supplier);

        SR ifSet(FieldMeta<T> field, BiFunction<FieldMeta<T>, Object, Expression> valueOperator, Function<String, ?> function, String keyName);

    }


    interface _DynamicAssignmentSetClause<T, SD> {

        SD sets(Consumer<Assignments<T>> consumer);

        SD ifSets(Consumer<Assignments<T>> consumer);
    }


    interface _CommaFieldValuePairClause<T, SR> {

        SR comma(FieldMeta<T> field, @Nullable Object value);

        SR commaLiteral(FieldMeta<T> field, @Nullable Object value);

        SR commaExp(FieldMeta<T> field, Supplier<? extends Expression> supplier);


    }


}
