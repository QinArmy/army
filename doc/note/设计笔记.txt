
1. 放弃 LongExpression ,IntegerExpresion ,NumberExpresioin 的原因
(1)Java 没有对整形作抽象(Integer,Long,BigInteger 没有共同的抽象类或接口),这使得Army的接口和实现太复杂.
(2)数据库本身能够对 非整形的数据进行按位操作,支持对非数据类型进行加减.

2. 为什么 io.army.criteria.Select.SelectSQLAble 没有 直接转换为子查询的方法,
因为这样容易让开发者偷懒把外层查询转变为子查询,这样会造成一旦相应的普通查询修改就会造成对应的子查询出bug。

3. 为什么 把 SelectSQLAble 设计为不同体系
(1) 让各数据库的特点尽可能的发挥,在现实开发中更换数据库的情况并不多见.
(2) 让子四种子查询(scale,column,row,table)的API更简洁而直接.
(3) 在实现的复杂和使用的简洁性的平衡下，选择多体系方案.
(4) 子查询和外层查询的语法不同,比如 锁语法.


4. 为什么设计 SQLS.ref(String,String) ?
(1) 为了在外层查询的 select 子句中 引用 SubQuery 的 Selection .
(2) 避免重复创建 RefSelection.

5. 为什么设计  SelectionGroup ?
(1) 可以减少不必要的 RefSelection 对象的创建,提高运行效率.
(2) 可以减少不必要的 AliasField 对象的创建,提高运行效率.
(3) 简化 select 子句的 api,如 : select t1.*,t2.*,subQueryAlias.* from t1 join t2 on xxx join () as subQueryAlias .
(4) 当 TableMeta 在 Select SQL 的 from 子句 和 join 子句 总共只出现一次时,
可以将 TableMeta 的 FieldMeta 封装成一个 SelectionGroup,且生成的 sql 中 对应的FieldMeta 有表别名.

6. 为什么不在 Select 的内部接口中 加上 List<SQLModifier> modifierList 或  <M extends SQLModifier> List<S> modifierList
参数的方法?
(1) 在数据库变更时 这样的 api 不容易发现 bug, 也正因为如此 MySQL 的专用 api 参数才使用 枚举 MySQLModifier
 而不是使用 接口 SQLModifier .

7. 为什么把 标准 API 各个数据库的专用 API 写在不同的模块?
(1) 因为在变更数据库是只要把相应的 maven 模块移出,就在找到需要修改的地方.


